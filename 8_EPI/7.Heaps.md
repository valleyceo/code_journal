# Heaps

<details>
<summary> Heaps </summary>

---
- Find the top k longest string (each node represents length of a string)
---

```cpp
vector<string> TopK (int k, vector<string>::const_iterator stream_begin,
					 const vector<string>::const_iterator& stream_end) 
{
	priority_queue<string, vector<string>, function<bool(string, string)>>
	min_heap([](const straing& a, const string& b) 
	{
		return size(a) >= size(b);
	});

	while (stream_begin != stream_end) 
	{
		min_heap.emplace(*stream_begin);
			if (size(min_heap) > k) 
			{
				min_heap.pop();
			}

			stream_begin = next(stream_begin);
	}

	vector<string> result;
	while (!empty(min_heap))
	{
		result.emplace_back(min_heap.top());
		min_heap.pop();
	}

	return result;
}

```

---
- Time complexity: Lookup O(1), string process O(logK), total process O(nlogK)

---
</details>


<details>
<summary> Merge Sorted Files (need to review) </summary>

---
- Given a set of sorted sequences
- Find the union of them in sorted sequence.
- EX: <3,5,7>, <0,6>, <0,6,28> -> <0,0,3,5,6,6,7,28>

---

```cpp
// overwrite operator >
struct IteratorCurrentAndEnd {
	bool operator>(const IteratorCurrentAndEnd& that) const {
		return *current > *that.current;
	}

	vector<int>::const_iterator current;
	vector<int>::const_iterator end;
}

vector<int> MergeSortedArrays (const vector<vector<int>>& sorted_arrays) {
	priority_queue<IteratorCurrentAndEnd, vector<IteratorCurrentAndEnd>, greater<>> min_heap;

	for (const vector<int>& sorted_array: sorted_arrays) {
		if (!empty(sorted_array)) {
			min_heap.emplace(
				IteratorCurrentAndEnd{cbegin(sorted_array), cend(sorted_array)});
		}
	}

	vector<int> result;
	while (!empty(min_heap)) {
		IteratorCurrentAndEnd smallest_array = min_heap.top();
		min_heap.pop();
		result.emplace_back(*smallest_array.current);
		if (next(smallest_array.current) != smallest_array.end) {
			min_heap.emplace(IteratorCurrentAndEnd{next(smallest_array.current), smallest_array.end});
		}
	}
	return result;
}
```

---
- Time complexity: O(nlogk)

---
</details>